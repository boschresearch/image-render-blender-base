#!/usr/bin/env python3
# -*- coding:utf-8 -*-
###
# File: /cls_fileout.py
# Created Date: Thursday, October 22nd 2020, 1:20:27 pm
# Author: Christian Perwass
# <LICENSE id="GPL-3.0">
#
#   Image-Render Blender base functions module
#   Copyright (C) 2022 Robert Bosch GmbH and its subsidiaries
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
#
# </LICENSE>
###

# Compositor class to handle

import os
import bpy

from anybase.cls_any_error import CAnyError_Message

# Example lFileOut list structure to use with SetFileOut()
# lFileOut = [
#     {
#         "sOutput": "Image",
#         "sFolder": "Image",
#         "sFilename": "Exp_######",
#         "mFormat" : {
#             "sFileFormat": "OPEN_EXR",
#             "sCodec": "ZIP",
#             "sColorDepth": "32"
#        }
#    },
#     {
#         "sOutput": "ImageDepth",
#         "sFolder": "ImageDepth",
#         "sFilename": "Exp_######",
#         "mFormat" : {
#             "sFileFormat": "JPEG",
#             "sColorDepth": "8",
#             "iQuality": 50
#        }
#    },
#     {
#         "sOutput": "Image",
#         "sFolder": "ImagePng",
#         "sFilename": "Exp_######",
#         "mFormat" : {
#             "sFileFormat": "PNG",
#             "sColorDepth": "16",
#             "iCompression": 80
#        }
#    }
# ]


class CFileOut:

    #######################################################################################################
    # Constructor
    def __init__(self, _xScene):

        self.xScn = _xScene
        self.xNT = self.xScn.node_tree

        if self.xNT is None:
            raise CAnyError_Message(sMsg="No compositor node tree available")
        # endif

        self.dicOut = self._GetOutputs()

    # enddef

    #######################################################################################################
    # Update Outputs
    def UpdateOutputs(self):
        self.dicOut = self._GetOutputs()

    # enddef

    #######################################################################################################
    # Private function that reads all Catharsys output nodes from compositor node tree
    def _GetOutputs(self):
        dicOut = {}

        for xNode in self.xNT.nodes:
            if xNode.label.startswith("Out:"):
                lLabel = xNode.label.split(":")
                dicOut[lLabel[1]] = {"sPixelType": lLabel[2], "xNode": xNode}
            # endif
        # endfor

        return dicOut

    # enddef

    #######################################################################################################
    # Get list of filenames generated by compositor output node for given frame number
    def GetOutputFilenames(self, _iFrame):

        # Output filepaths
        lFpOut = []

        # Get all file output nodes
        lNodeFo = [x for x in self.xNT.nodes if x.name.startswith("File Output")]

        # For all file output nodes
        for xNodeFo in lNodeFo:
            sBasePath = os.path.normpath(xNodeFo.base_path)
            for sRelPath in xNodeFo.file_slots.keys():
                xFsf = xNodeFo.file_slots[sRelPath]
                sFileType = xFsf.format.file_format
                sExt = ""
                if sFileType == "OPEN_EXR":
                    sExt = ".exr"
                elif sFileType == "JPEG":
                    sExt = ".jpg"
                elif sFileType == "PNG":
                    sExt = ".png"
                else:
                    raise Exception("Unsupported file format '{0}'".format(sFileType))
                # endif

                # Find placeholder '#'
                iIdx = sRelPath.find("#")
                if iIdx < 0:
                    sFpOut = os.path.join(
                        sBasePath, sRelPath + "{0}".format(_iFrame) + sExt
                    )
                else:
                    iLast = sRelPath.rfind("#")
                    sPre = ""
                    if iIdx > 0:
                        sPre = sRelPath[0:iIdx]
                    # endif
                    sPost = ""
                    if iLast < len(sRelPath) - 1:
                        sPost = sRelPath[iLast + 1 :]
                    # endif
                    iCnt = iLast - iIdx + 1
                    sF = "{{0:0{0}d}}".format(iCnt)
                    sFileOut = sPre + sF.format(_iFrame) + sPost + sExt
                    sFpOut = os.path.normpath(os.path.join(sBasePath, sFileOut))
                # endif
                lFpOut.append(sFpOut)
            # endfor
        # endfor

        return lFpOut

    # endif

    #######################################################################################################
    # Set the file output compositor node according to _lFileOut structure
    def SetFileOut(self, _sBasePath, _lFileOut):

        # Test whether the list of file outputs uses the same folder multiple times.
        lFolder = []
        for dicFo in _lFileOut:
            sFolder = dicFo.get("sFolder")
            if sFolder in lFolder:
                raise Exception(
                    "File output folder '{0}' is used multiple times.".format(sFolder)
                )
            # endif
            lFolder.append(sFolder)
        # endfor

        # Remove all other "File Output" nodes
        lNodeFo = [x for x in self.xNT.nodes if x.name.startswith("File Output")]
        for xFo in lNodeFo:
            self.xNT.nodes.remove(xFo)
        # endfor

        # Create new "File Output" node
        xFo = self.xNT.nodes.new(type="CompositorNodeOutputFile")

        # Set the base path
        xFo.base_path = _sBasePath

        # Get the file slots
        xFs = xFo.file_slots

        # Empty the file slots
        xFs.clear()

        # Create file slots for all elements in _lFileOut
        for dicFo in _lFileOut:
            sOutput = dicFo.get("sOutput")
            if sOutput not in self.dicOut:
                raise Exception(
                    "Output with id '{0}' is not available in compositor.".format(
                        sOutput
                    )
                )
            # endif

            xNode = self.dicOut[sOutput].get("xNode")
            if xNode is None:
                raise Exception(f"Node '{sOutput}' does not exist")
            # endif

            if len(xNode.outputs) == 0:
                raise Exception(f"Node '{sOutput}' does not have output sockets")
            # endif

            # Get the pixel type of the output
            sPixelType = self.dicOut[sOutput].get("sPixelType")

            sSlotId = "{0}/{1}".format(dicFo.get("sFolder"), dicFo.get("sFilename"))

            # Create a new slot
            xSlotIn = xFs.new(sSlotId)
            # Get the file out data object
            xSlotFile = xFs[xSlotIn.name]
            # Do not use the over image format of the node
            xSlotFile.use_node_format = False

            # Get the file format object
            xFf = xSlotFile.format

            # Get the file format
            dicFormat = dicFo.get("mFormat")
            sFileFormat = dicFormat.get("sFileFormat")
            if sFileFormat == "OPEN_EXR":
                xFf.file_format = sFileFormat
                xFf.exr_codec = dicFormat.get("sCodec", "ZIP")

                if sPixelType == "BW" or sPixelType == "RGB":
                    xFf.color_mode = "RGB"
                elif sPixelType == "RGBA":
                    xFf.color_mode = "RGBA"
                else:
                    raise Exception(
                        "Invalid pixel type '{0}' for OpenEXR file format.".format(
                            sPixelType
                        )
                    )
                # endif

                sColDepth = dicFormat.get("sColorDepth", "32")
                if sColDepth == "16" or sColDepth == "32":
                    xFf.color_depth = sColDepth
                else:
                    raise Exception(
                        "Invalid pixel color bit depth '{0}' for OpenEXR file format.".format(
                            sColDepth
                        )
                    )
                # endif
            elif sFileFormat == "JPEG":
                xFf.file_format = "JPEG"

                if sPixelType == "BW":
                    xFf.color_mode = "BW"
                elif sPixelType == "RGB" or sPixelType == "RGBA":
                    xFf.color_mode = "RGB"
                else:
                    raise Exception(
                        "Invalid pixel type '{0}' for JPEG file format.".format(
                            sPixelType
                        )
                    )
                # endif

                sColDepth = dicFormat.get("sColorDepth", "8")
                if sColDepth == "8":
                    xFf.color_depth = sColDepth
                else:
                    raise Exception(
                        "Invalid pixel color bit depth '{0}' for JPEG file format.".format(
                            sColDepth
                        )
                    )
                # endif

                iQuality = dicFormat.get("iQuality", 90)
                if iQuality < 0 or iQuality > 100:
                    raise Exception(
                        "Invalid quality value '{0}' for JPEG file format.".format(
                            iQuality
                        )
                    )
                # endif
                xFf.quality = iQuality

            elif sFileFormat == "PNG":
                xFf.file_format = "PNG"

                if sPixelType in ["BW", "RGB", "RGBA"]:
                    xFf.color_mode = sPixelType
                else:
                    raise Exception(
                        "Invalid pixel type '{0}' for PNG file format.".format(
                            sPixelType
                        )
                    )
                # endif

                sColDepth = dicFormat.get("sColorDepth", "8")
                if sColDepth in ["8", "16"]:
                    xFf.color_depth = sColDepth
                else:
                    raise Exception(
                        "Invalid pixel color bit depth '{0}' for PNG file format.".format(
                            sColDepth
                        )
                    )
                # endif

                iCompression = dicFormat.get("iCompression", 15)
                if iCompression < 0 or iCompression > 100:
                    raise Exception(
                        "Invalid compression value '{0}' for PNG file format.".format(
                            iCompression
                        )
                    )
                # endif
                xFf.compression = iCompression
            else:
                raise Exception("Unsupported file format '{0}'.".format(sFileFormat))
            # endif

            # connect output to input
            self.xNT.links.new(self.dicOut[sOutput].get("xNode").outputs[0], xSlotIn)

        # endfor

    # enddef


# endclass
